<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>quiver</title>
    <link rel="icon" href="icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
        }

        .box {
            position: absolute;
            background: darkslategrey;
            border-radius: 16px;
        }

        svg {
            overflow: visible;
            position: absolute;
            pointer-events: none;
            /* background: hsla(0, 0%, 0%, 0.3); */
        }
    </style>
    <script type="text/javascript" src="ds.js"></script>
    <script type="text/javascript" src="dom.js"></script>
    <script type="text/javascript" src="bezier.js"></script>
    <script type="text/javascript" src="arrow.js"></script>
    <script>
        // *** WORK TILL COMPLETION ***
        //
        // ** Critical features & Bugs **
        // - Make sure we can draw pretty arrows between arrows.
        // - Make smooth transitions from small edges to long edges (scaling heads, etc.).
        // - Crop space for the label.
        // - Make label handling work well when edge is very small (and when the label contains the edge).
        // - Make n-cells draw well even for high n.
        // - Test and make sure everything looks pixel perfect. Set up a test rig.
        // - Cropping of background.
        // - Add mask for "none" tail for squiggly lines (could maybe use the existing mask background).
        //
        // ** quiver integration **
        // - Use the new arrow library for quiver.
        // - Figure out how to export appropriate tikz-cd code for curved edges.
        //
        // ** Extra features **
        // - Loops.
        // - Saving as SVG.

        let drag = null;

        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 64;
                this.height = 64;
                this.radius = 16;
                this.svg = document.createElement("div");
                this.svg.classList.add("box");
                this.redraw();
                this.svg.addEventListener("mousedown", (event) => {
                    if (drag === null) {
                        const rect = this.svg.getBoundingClientRect();
                        drag = [this, event.clientX - rect.left - this.width / 2, event.clientY - rect.top - this.height / 2];
                    }
                });
                document.body.appendChild(this.svg);
            }

            get origin() {
                return new Point(this.x, this.y);
            }

            redraw() {
                this.svg.style.left = `${this.x - this.width / 2}px`;
                this.svg.style.top = `${this.y - this.height / 2}px`;
                this.svg.style.width = `${this.width}px`;
                this.svg.style.height = `${this.height}px`;
            }
        }

        window.addEventListener("mouseup", () => {
            drag = null;
        });

        document.addEventListener("DOMContentLoaded", () => {
            const source = new Shape(64, 240);
            const target = new Shape(640, 240);
            // const arrow2 = new Arrow2(source, target);

            const arrow = new Arrow(source, target, new ArrowStyle(), new Label("Hello"));
            arrow.style.heads = ["epi"];
            arrow.style.tails = ["mono"];
            arrow.style.level = 1;
            // arrow.style.dash_style = CONSTANTS.ARROW_DASH_STYLE.DASHED;
            arrow.style.body_style = CONSTANTS.ARROW_BODY_STYLE.SQUIGGLY;
            arrow.label.alignment = CONSTANTS.LABEL_ALIGNMENT.RIGHT;
            arrow.redraw();
            document.body.appendChild(arrow.background.element);
            document.body.appendChild(arrow.svg.element);

            window.addEventListener("mousemove", (event) => {
                if (drag !== null) {
                    const [shape, x, y] = drag;
                    shape.x = event.clientX - x;
                    shape.y = event.clientY - y;
                    shape.redraw();
                    arrow.redraw();
                }
            });

            window.addEventListener("wheel", (event) => {
                event.preventDefault();
                arrow.style.curve += event.deltaY;
                arrow.redraw();
            }, { passive: false });

            window.addEventListener("keydown", (event) => {
                let redraw = false;
                if (event.key === "ArrowLeft") {
                    --arrow.style.level;
                    redraw = true;
                }
                if (event.key === "ArrowRight") {
                    ++arrow.style.level;
                    redraw = true;
                }
                arrow.style.level = Math.max(1, arrow.style.level);
                if (redraw) {
                    arrow.redraw();
                }
            })
        });

        function visualise_rounded_rect(svg, x, y, w, h, border_radius) {
            const points = new RoundedRectangle(
                x, y, w, h, border_radius,
            ).points();
            let rr_path = "";
            let first = true;
            for (const p of points) {
                if (first) {
                    rr_path += `M ${p.x} ${p.y} `;
                    first = false;
                } else {
                    rr_path += `L ${p.x} ${p.y} `;
                }
            }

            new DOM.SVGElement("path", {
                d: rr_path,
                fill: "red",
                stroke: "none",
            }).add_to(svg);
        }
    </script>
</head>
<body>
</body>
</html>
