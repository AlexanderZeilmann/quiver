<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>quiver</title>
    <link rel="icon" href="icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
        }

        .box {
            position: absolute;
            background: darkslategrey;
            border-radius: 4px;
        }

        svg {
            overflow: visible;
            position: absolute;
            pointer-events: none;
            /* background: lightgrey; */
        }
    </style>
    <script type="text/javascript" src="ds.js"></script>
    <script type="text/javascript" src="dom.js"></script>
    <script>

        // TODO: cut head/tail as well as edge
        // TODO: make sure pixel perfect + 0.5px if necessary.
        // As many of the styles should be combinable (and parametric) as possible.

        // Remove rounded rect from svg drawing.
        // Find intersection of Bezier with rounded rect.
        // Draw tails.
        // Draw heads.
        // Draw multiple lines.

        let drag = null;
        let curve = 0;
        let level = 5;

        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 64;
                this.height = 64;
                this.svg = document.createElement("div");
                this.svg.classList.add("box");
                this.redraw();
                this.svg.addEventListener("mousedown", (event) => {
                    if (drag === null) {
                        const rect = this.svg.getBoundingClientRect();
                        drag = [this, event.clientX - rect.left - this.width / 2, event.clientY - rect.top - this.height / 2];
                    }
                });
                document.body.appendChild(this.svg);
            }

            redraw() {
                this.svg.style.left = `${this.x - this.width / 2}px`;
                this.svg.style.top = `${this.y - this.height / 2}px`;
                this.svg.style.width = `${this.width}px`;
                this.svg.style.height = `${this.height}px`;
            }
        }

        /// A helper class for dealing with symmetric quadratic Bézier curves.
        class Bezier {
            constructor(start, end, height) {
                this.start = start;
                this.end = end;
                this.height = height;

                // The control point. This is twice the distance from the straight line connecting `start`
                // and `end` as `height`.
                const midpoint = this.start.add(this.end).div(2);
                const normal = this.end.sub(this.start).atan() + Math.PI / 2;
                this.control = midpoint.add(Point.from_length_and_direction(this.height, normal));
            }

            /// Returns the (x, y)-point at t = `t`.
            point(t) {
                return this.start.lerp(this.control, t).lerp(this.control.lerp(this.end, t), t);
            }

            /// Returns the angle of the curve at t = `t`.
            angle(t) {
                return this.control.lerp(this.end, t).sub(this.start.lerp(this.control, t)).atan();
            }

            /// Returns the Bézier curve from t = 0 to t = `t` as a series of points corresponding
            /// to line segments, and their total length.
            /// `{ points, length }`
            delineate(t) {
                // How many pixels of precision we want for the length.
                const EPSILON = 0.25;

                // Start with a single, linear segment.
                const points = [[0, this.point(0)], [t, this.point(t)]];

                let previous_length;
                let length = 0;

                do {
                    // Calculate the current approximation of the arc length.
                    previous_length = length;
                    length = 0;
                    for (let i = 0; i < points.length - 1; ++i) {
                        length += points[i + 1][1].sub(points[i][1]).length();
                    }
                } while (length - previous_length > EPSILON && (() => {
                    // If we're still not within the required precision, double the number of segments.
                    for (let i = 0; i < points.length - 1; ++i) {
                        const t = (points[i][0] + points[i + 1][0]) / 2;
                        points.splice(++i, 0, [t, this.point(t)]);
                    }
                    return true;
                })());

                return { points, length };
            }

            /// Returns the arc length of the Bézier curve from t = 0 to t = `t`.
            /// These Bézier curves are symmetric, so t = `t` to t = 1 can be calculated by inverting the
            /// arc length from t = 0.
            arc_length(t) {
                const { length } = this.delineate(t);
                return length;
            }

            /// Returns a function giving the parameter t of the point a given length along the arc of
            /// the Bézier curve. (It returns a function, rather than the t for a length, to allow
            /// the segments to be cached for efficiency).
            /// The returned function does no error-checking, so ensure that it is only called with
            /// lengths between 0 and the arc length of the curve.
            t_after_length() {
                const { points } = this.delineate(1);
                return (length) => {
                    let distance = 0;
                    for (let i = 0; i < points.length - 1; ++ i) {
                        const segment_length = points[i + 1][1].sub(points[i][1]).length();
                        if (distance + segment_length >= length) {
                            // Lerp the t parameter.
                            return points[i][0]
                                + (points[i + 1][0] - points[i][0]) * (length - distance) / segment_length;
                        }
                        distance += segment_length;
                    }
                };
            }
        }

        class Arrow {
            constructor(source, target) {
                this.source = source;
                this.target = target;
                const ns = "http://www.w3.org/2000/svg";
                // We need to explicitly set the namespace attribute so that the SVG can be saved as
                // a standalone file.
                this.svg = new DOM.SVGElement("svg", { xmlns: ns });
                this.redraw();
                document.body.appendChild(this.svg.element);
            }

            redraw() {
                const SPACING = 4.5;
                const STROKE_WIDTH = 1.5;

                const body_shape = "squiggly"; // "squiggly" or "none"

                // The height (in pixels) of each triangle from the edge.
                const AMPLITUDE = 2;

                const PADDING_Y = body_shape === "squiggly" ? (AMPLITUDE + STROKE_WIDTH) * 2 : 0;

                const line_width = level * STROKE_WIDTH + (level - 1) * SPACING;

                const HEAD_WIDTH = SPACING + (level - 1) * 2;
                const HEAD_HEIGHT = line_width + SPACING * 2;

                const PADDING_X = HEAD_HEIGHT / 2;

                const length = Math.hypot(this.target.y - this.source.y, this.target.x - this.source.x);
                const height = Math.abs(curve) + HEAD_HEIGHT + PADDING_Y;
                const angle = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                this.svg.element.style.width = `${length + PADDING_X * 2}px`;
                this.svg.element.style.height = `${height}px`;
                this.svg.element.style.transformOrigin = `0 ${height / 2}px`;
                this.svg.element.style.transform = `translate(${this.source.x}px, ${this.source.y - height / 2}px) rotate(${angle}rad) translate(${-PADDING_X}px, 0)`;

                this.svg.element.innerHTML = "";
                this.svg.element.setAttribute("viewBox", `0 0 ${length} ${height}`);

                const PADDING_S = 15;
                const body_style = "none";

                const bg = new DOM.SVGElement("path", {
                    d: `M 0 ${height / 2} q ${length / 2} ${curve} ${length} 0`,
                    fill: "none",
                    stroke: "hsla(0, 0%, 0%, 0.2)",
                    "stroke-width": line_width + PADDING_S * 2,
                    "stroke-linecap": "round", // could use: http://web.cse.ohio-state.edu/~dey.8/course/784/note9.pdf
                }).add_to(this.svg);
                const line = new DOM.SVGElement("path", {
                    mask: "url(#clip)",
                    fill: "none",
                    stroke: "black",
                    "stroke-width": line_width,
                }).add_to(this.svg);
                if (body_style === "dashed") {
                    line.setAttribute("stroke-dasharray", "6");
                } else if (body_style === "dotted") {
                    line.setAttribute("stroke-dasharray", "2 4");
                }

                const defs = new DOM.SVGElement("defs").add_to(this.svg);
                const clip = new DOM.SVGElement("mask", {
                    id: "clip",
                    maskUnits: "userSpaceOnUse",
                }).add_to(defs);

                const fill = new DOM.SVGElement("rect", {
                    width: length + PADDING_X * 2,
                    height,
                    x: -PADDING_X,
                    fill: "white",
                }).add_to(clip);

                const [label_width, label_height] = [128, 32];
                const label = new DOM.SVGElement("rect", {
                    width: label_width,
                    height: label_height,
                    x: (length - label_width) / 2,
                    y: (height - label_height + curve) / 2,
                    fill: "lime",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                }).add_to(this.svg);
                const text = new DOM.SVGElement("text", {
                    x: length / 2,
                    y: (height + curve) / 2,
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                    "text-anchor": "middle",
                    "dominant-baseline": "middle",
                }).add_to(this.svg);
                text.element.innerHTML = "Label";

                const ir = (colour, rect, resolve) => {
                    const intersections = intersect_bezier_with_rect(
                        rect.x,
                        rect.y,
                        rect.width,
                        rect.height,
                        new NormalisedBezier(new Point(this.source.x, this.source.y), angle, length, curve),
                        resolve,
                    );
                    for (const inter of intersections) {
                        new DOM.SVGElement("circle", {
                            cx: inter.x,
                            cy: inter.y + height / 2,
                            r: 8,
                            fill: colour,
                        }).add_to(this.svg);
                    }
                    return intersections.length > 0 ? intersections[0] : null;
                };

                const start = ir("none", this.source, true);
                const end = ir("none", this.target, false);

                const path = [`M 0 ${height / 2}`];
                if (body_shape === "none") {
                    path.push(`q ${length / 2} ${curve} ${length} 0`);
                } else if (body_shape === "squiggly") {
                    if (start === null || end === null) {
                        console.error("no start/end");
                    }
                    // When we draw squiggly lines, we essentially have to draw the
                    // Bézier curve by ourselves, using line segments, so that we can
                    // transform it (i.e. add the triangle waveform pattern).
                    const bezier = new Bezier(Point.zero(), new Point(length, 0), curve);

                    // Each triangle has a width equal to twice its height.
                    const HALF_WAVELENGTH = AMPLITUDE * 2;

                    // Padding at the start of the edge (measured in triangles), where the curve
                    // will be flat (though possibly curved).
                    const PADDING = 1;

                    // We provide twice as much padding for the head as for the tail.
                    const heads = 1;
                    const head_padding = PADDING * (1 + heads);

                    // Draw the padding at the tail of the arrow.
                    const SVG_PADDING = 0;
                    const line_length = length;
                    const angle = bezier.angle(0);

                    const arc_length = bezier.arc_length(end.t) - bezier.arc_length(start.t);
                    const t_after_length = bezier.t_after_length();
                    const squiggle_length = bezier.arc_length(end.t) - (HEAD_WIDTH + HALF_WAVELENGTH * head_padding);

                    // should really be tail width
                    const st = bezier.arc_length(start.t) + HEAD_WIDTH + HALF_WAVELENGTH * head_padding;
                    let ll = t_after_length(st);
                    let lp = bezier.point(ll);
                    path.push(`l ${lp.x} ${lp.y}`);

                    for (
                        // The current (arc) length along the curve.
                        let l = st,
                        // Which direction to draw the triangle (`-1` or `1`).
                        sign = -1,
                        // Whether to draw offset by `AMPLITUDE` (`1`) or not (`0`).
                        m = 1;
                        l + m * HALF_WAVELENGTH / 2 < squiggle_length;
                        // Flip the direction of the triangle each time a triangle
                        // is drawn. We alternate between drawing tips and bases of
                        // the triangles.
                        sign = [sign, -sign][m], m = 1 - m
                    ) {
                        l += HALF_WAVELENGTH / 2;
                        const t = t_after_length(l);
                        const point = bezier.point(t);
                        const angle = bezier.angle(t) + Math.PI / 2 * sign;
                        path.push(`L ${
                            point.x + Math.cos(angle) * AMPLITUDE * m
                        } ${
                            height / 2 + point.y + Math.sin(angle) * AMPLITUDE * m
                        }`);
                    }

                    // Draw the padding at the head of the arrow.
                    path.push(`L ${SVG_PADDING + line_length} ${
                        SVG_PADDING + height / 2
                    }`);
                }

                let cut = true;
                for (let i = level - 1; i > 0; --i) {
                    new DOM.SVGElement("path", {
                        d: path.join("\n"),
                        fill: "none",
                        stroke: cut ? "black" : "white",
                        "stroke-width": `${(i - (cut ? 1 : 0)) * STROKE_WIDTH + (i - (cut ? 0 : 1)) * SPACING}`,
                    }).add_to(clip);
                    cut = !cut;
                }

                new DOM.SVGElement("rect", {
                    width: this.source.width,
                    height: this.source.height,
                    x: -this.source.width / 2,
                    y: (height - this.source.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} 0 ${height / 2})`,
                    rx: 4,
                }).add_to(clip);

                new DOM.SVGElement("rect", {
                    width: this.target.width,
                    height: this.target.height,
                    x: length - this.target.width / 2,
                    y: (height - this.target.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length} ${height / 2})`,
                    rx: 4,
                }).add_to(clip);

                line.element.setAttribute("d", path.join("\n"));

                const create_head = (type, where, is_start, mask) => {
                    if (where !== null) {
                        const head = new DOM.SVGElement("path", {
                            fill: mask ? "black" : "none",
                            stroke: !mask ? "black" : "none",
                            "stroke-width": STROKE_WIDTH,
                        });
                        const mul = is_start ? 1 : -1;
                        const flag = is_start ? 0 : 1;
                        const head_path = new Path();
                        if (type === "arrowhead") {
                            for (const [iflag, imul] of [[flag, -1], [1 - flag, 1]]) {
                                head_path.move_to(where.x, where.y + height / 2);
                                head_path.arc_by(
                                    mul * HEAD_WIDTH,
                                    HEAD_HEIGHT / 2,
                                    0,
                                    false,
                                    iflag,
                                    mul * HEAD_WIDTH,
                                    imul * HEAD_HEIGHT / 2,
                                );
                                if (mask) {
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                    );
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + where.y,
                                    );
                                }
                            }
                            head.element.setAttribute("d", head_path.toString());
                            head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                        } else if (type === "epi") {
                            const HEAD_SPACING = HEAD_WIDTH / 2 + 2;
                            const heads = 2;
                            for (let i = heads - 1; i >= 0; --i) {
                                for (const [iflag, imul] of [[flag, -1], [1 - flag, 1]]) {
                                    head_path.move_to(
                                        where.x + mul * HEAD_SPACING * i,
                                        where.y + height / 2,
                                    );
                                    head_path.arc_by(
                                        mul * HEAD_WIDTH,
                                        HEAD_HEIGHT / 2,
                                        0,
                                        false,
                                        iflag,
                                        mul * HEAD_WIDTH,
                                        imul * HEAD_HEIGHT / 2,
                                    );
                                    if (i === heads - 1 && mask) {
                                        head_path.line_to(
                                            where.x + mul * (HEAD_WIDTH + HEAD_SPACING) * i,
                                            height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                        );
                                        head_path.line_to(
                                            where.x + mul * HEAD_SPACING * i - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                            height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                        );
                                        head_path.line_to(
                                            where.x + mul * HEAD_SPACING * i - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                            height / 2 + where.y,
                                        );
                                    }
                                }
                            }
                            head.element.setAttribute("d", head_path.toString());
                            head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                        } else if (type === "mono") {
                            for (const [iflag, imul] of [[1 - flag, -1], [flag, 1]]) {
                                head_path.move_to(where.x + mul * HEAD_WIDTH, where.y + height / 2);
                                head_path.arc_by(
                                    mul * HEAD_WIDTH,
                                    HEAD_HEIGHT / 2,
                                    0,
                                    false,
                                    iflag,
                                    -mul * HEAD_WIDTH,
                                    imul * HEAD_HEIGHT / 2,
                                );
                                if (mask) {
                                    head_path.line_to(
                                        where.x + mul * HEAD_WIDTH,
                                        height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                    );
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                    );
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + where.y,
                                    );
                                }
                            }
                            head.element.setAttribute("d", head_path.toString());
                            head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                        } else if (type === "maps to") {
                            const OFFSET_PADDING = 12;
                            for (const imul of [-1, 1]) {
                                head_path.move_to(where.x + mul * OFFSET_PADDING, where.y + height / 2);
                                head_path.line_by(0, imul * HEAD_HEIGHT / 2);
                                if (mask) {
                                    head_path.line_to(
                                        where.x + mul * HEAD_WIDTH,
                                        height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                    );
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + imul * HEAD_HEIGHT / 2 + where.y,
                                    );
                                    head_path.line_to(
                                        where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                        height / 2 + where.y,
                                    );
                                }
                            }
                            head.element.setAttribute("d", head_path.toString());
                            head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                        } else if (type.startsWith("harpoon")) {
                            // TODO: this should be shifted up
                            const h = line_width + SPACING;
                            const flip = type.endsWith("top") ? 1 : -1;
                            head_path.move_to(
                                where.x,
                                where.y + height / 2 + flip * line_width / 2,
                            );
                            head_path.arc_by(
                                mul * HEAD_WIDTH,
                                h,
                                0,
                                false,
                                flip === 1 ? flag : 1 - flag,
                                mul * HEAD_WIDTH,
                                -h * flip,
                            );
                            if (mask) {
                                head_path.line_to(
                                    where.x + mul * HEAD_WIDTH,
                                    height / 2 - (line_width / 2 + SPACING) * flip + where.y,
                                );
                                head_path.line_to(
                                    where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                    height / 2 - (line_width / 2 + SPACING) * flip + where.y + flip * STROKE_WIDTH * 2,
                                );
                                head_path.line_to(
                                    where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                    height / 2 + flip * line_width / 2 + where.y + flip * STROKE_WIDTH * 2,
                                );
                            }
                            head.element.setAttribute("d", head_path.toString());
                            head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                        } else if (type === "none") {
                            // Don't do anything.
                            // TODO: should probably draw padding, though
                        }
                        return head;
                    }
                    return null;
                }

                let draw_head = (type, where, is_start) => {
                    const head = create_head(type, where, is_start, false);
                    if (head !== null) {
                        this.svg.add(head);
                    }
                    const mask = create_head(type, where, is_start, true);
                    if (mask !== null) {
                        clip.add(mask);
                    }
                    // const head2 = create_head(type, where, is_start, false);
                    // if (head2 !== null) {
                    //     head2.style.stroke = "white";
                    //     clip.appendChild(head2);
                    // }
                };
                draw_head("harpoon-top", start, true);
                draw_head("harpoon-top", end, false);
            }
        }

        window.addEventListener("mouseup", () => {
            drag = null;
        });

        document.addEventListener("DOMContentLoaded", () => {
            const source = new Shape(64, 240);
            const target = new Shape(640, 240);
            const arrow = new Arrow(source, target);

            window.addEventListener("mousemove", (event) => {
                if (drag !== null) {
                    const [shape, x, y] = drag;
                    shape.x = event.clientX - x;
                    shape.y = event.clientY - y;
                    shape.redraw();
                    arrow.redraw();
                }
            });

            window.addEventListener("wheel", (event) => {
                event.preventDefault();
                curve += event.deltaY;
                arrow.redraw();
            }, { passive: false });

            window.addEventListener("keydown", (event) => {
                let redraw = false;
                if (event.key === "ArrowLeft") {
                    --level;
                    redraw = true;
                }
                if (event.key === "ArrowRight") {
                    ++level;
                    redraw = true;
                }
                level = Math.max(1, level);
                if (redraw) {
                    arrow.redraw();
                }
            })
        });

        /// The normalised quadratic Bézier curve is the one whose endpoints are (0, 0) and (1, 0)
        /// and whose control point is (0.5, 1). The highest point on the curve is therefore
        /// (0.5, 0.5). The equation of the curve is `y = 2 x (1 - x)`.

        /// Intersects the rectangle centred on `(x, y)` of width `w` and height `h` with the
        /// Bézier curve `b`.
        /// Note that intersecting a Bézier curve with a circle is very difficult in general, so we
        /// approximate rounded rectangles by rectanges for the sake of finding intersections.
        function intersect_bezier_with_rect(x, y, w, h, b, min = true) {
            let points = new Array(4).fill(null).map(() => new Point(x, y));
            points[0] = points[0].sub(new Point(w/2, h/2));
            points[1] = points[1].sub(new Point(-w/2, h/2));
            points[2] = points[2].sub(new Point(-w/2, -h/2));
            points[3] = points[3].sub(new Point(w/2, -h/2));

            let intersections = [];
            let h_scale = b.h || 1;
            points = points.map((p) => normalise_point(p, new NormalisedBezier(b.o, b.theta, b.l, h_scale)));

            const EPSILON = 10 ** (-10);

            if (b.h === 0) {
                // Special-case a straight line, as we can't normalise with respect to this curve.
                // We're now trying to intersect with a horizontal line (0, 0) to (1, 0).
                for (let i = 0; i < 4; ++i) {
                    const endpoints = [points[i], points[(i + 1) % 4]];
                    if (Math.abs(endpoints[0].x - endpoints[1].x) <= EPSILON) {
                        // x = a.
                        if (endpoints[0].x >= 0 && endpoints[0].x <= 1 && Math.min(endpoints[0].y, endpoints[1].y) <= 0 &&
                            Math.max(endpoints[0].y, endpoints[1].y) >= 0) {
                                intersections.push(new Point(endpoints[0].x, 0));
                            }
                    } else {
                        const m = (endpoints[1].y - endpoints[0].y) / (endpoints[1].x - endpoints[0].x);
                        const c = endpoints[0].y - m * endpoints[0].x;
                        if (m !== 0) {
                            const x = -c / m;
                            if (x >= 0 && x <= 1) {
                                intersections.push(new Point(x, 0));
                            }
                        } else if (Math.abs(endpoints[0].y) <= EPSILON) {
                            // Lines lie along one another.
                            const mn = Math.min(endpoints[0].x, endpoints[1].x);
                            const mx = Math.max(endpoints[0].x, endpoints[1].x);
                            if (mn <= 1 && mx >= 0) {
                                intersections.push(new Point(Math.max(mn, 0), 0));
                                intersections.push(new Point(Math.min(mx, 1), 0));
                            }
                        }
                    }
                }
            } else {
                // Usual case. Non-trivial.
                for (let i = 0; i < 4; ++i) {
                    const endpoints = [points[i], points[(i + 1) % 4]];
                    // Special-case the vertical line, within some margin of precision to avoid floating-point artefacts.
                    if (Math.abs(endpoints[0].x - endpoints[1].x) <= EPSILON) {
                        const y = intersect_bezier_with_vertical_line(endpoints[0].x);
                        if (y >= 0 && y >= Math.min(endpoints[0].y, endpoints[1].y) && y <= Math.max(endpoints[0].y, endpoints[1].y)) {
                            // `y` must be at most 0.5.
                            intersections.push(new Point(endpoints[0].x, y));
                        }
                    } else {
                        const m = (endpoints[1].y - endpoints[0].y) / (endpoints[1].x - endpoints[0].x);
                        const c = endpoints[0].y - m * endpoints[0].x;
                        // Horizontal or sloping lines.
                        intersections = intersections.concat(
                            intersect_bezier_with_line(m, c)
                                .filter((x) => x >= 0 && x <= 1 && x >= Math.min(endpoints[0].x, endpoints[1].x) && x <= Math.max(endpoints[0].x, endpoints[1].x))
                                .map((x) => new Point(x, m * x + c))
                        );
                    }
                }
            }

            // There should be at most one intersection point: any more indicates the Bézier curve
            // is very thin, in which case we pick the point closest to the start of the curve if
            // `min` is true, or the end otherwise.
            min = min ? -1 : 1;
            intersections.sort((a, b) => a.x <= b.x ? min : -min);

            // Derivative of Bézier curve is `2 - 4x`.
            return intersections.slice(0, 1)
                .map(p => Object.assign({ t: p.x, angle: Math.atan2((2 - 4 * p.x) * h_scale, b.l) }, p.scale(b.l, h_scale)));
        }

        /// Intersect the line `y = m x + c` with the normalised quadratic Bézier curve and return
        /// the `x` co-ordinate.
        function intersect_bezier_with_line(m, c) {
            const determinant = m ** 2 - 4 * m + 4 - 8 * c;
            if (determinant > 0) {
                return [(2 - m + determinant ** 0.5) / 4, (2 - m - determinant ** 0.5) / 4];
            } else if (determinant === 0) {
                return [(2 - m + determinant ** 0.5) / 4];
            } else {
                return [];
            }
        }

        /// Intersect the line `x = a` with the normalised quadratic Bézier curve and return the `y`
        /// co-ordinate.
        function intersect_bezier_with_vertical_line(a) {
            return 2 * a * (1 - a);
        }

        /// Normalise a point `p` with respect to the Bézier curve `b`.
        function normalise_point(p, b) {
            // Translate the point with respect to the origin.
            p = p.sub(b.o);
            // Rotate -θ around the origin.
            p = p.rotate(-b.theta);
            // Scale the point horizontally and vertically.
            p = p.inv_scale(b.l, b.h);
            return p;
        }

        class NormalisedBezier {
            /// A Bézier curve with origin `o`, angle `theta`, length `l` and (control point)
            /// height `h`.
            constructor(o, theta, l, h) {
                this.o = o;
                this.theta = theta;
                this.l = l;
                this.h = h;
            }
        }

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            static zero() {
                return new Point(0, 0);
            }

            static from_length_and_direction(length, direction) {
                return new Point(Math.cos(direction) * length, Math.sign(direction) * length);
            }

            add(p) {
                return new (this.constructor)(this.x + p.x, this.y + p.y);
            }

            sub(p) {
                return new (this.constructor)(this.x - p.x, this.y - p.y);
            }

            mul(multiplier) {
                return new (this.constructor)(this.x * multiplier, this.y * multiplier);
            }

            div(divisor) {
                return new (this.constructor)(this.x / divisor, this.y / divisor);
            }

            rotate(theta) {
                return new (this.constructor)(
                    this.x * Math.cos(theta) - this.y * Math.sin(theta),
                    this.y * Math.cos(theta) + this.x * Math.sin(theta),
                );
            }

            scale(w, h) {
                return new (this.constructor)(this.x * w, this.y * h);
            }

            inv_scale(w, h) {
                return new (this.constructor)(this.x / w, this.y / h);
            }

            lerp(other, t) {
                return this.add(other.sub(this).mul(t));
            }

            atan() {
                return Math.atan2(this.y, this.x);
            }

            length() {
                return Math.hypot(this.y, this.x);
            }
        }
    </script>
</head>
<body>
</body>
</html>
