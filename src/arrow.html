<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>quiver</title>
    <link rel="icon" href="icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
        }

        .box {
            position: absolute;
            background: darkslategrey;
            border-radius: 16px;
        }

        svg {
            overflow: visible;
            position: absolute;
            pointer-events: none;
            /* background: lightgrey; */
        }
    </style>
    <script type="text/javascript" src="ds.js"></script>
    <script type="text/javascript" src="dom.js"></script>
    <script type="text/javascript" src="bezier.js"></script>
    <script type="text/javascript" src="arrow.js"></script>
    <script>

        // TODO: add the remaining arrow types: fix the harpoon style.
        // TODO: make sure we can draw arrows between arrows and that they get cropped properly.
        // TODO: make the transition from short arrows to long arrows smooth (e.g. scaling heads, etc.)
        // TODO: add cropping of other arrows (e.g. depth/crossing-over), as well as the label box.
        // TODO: make sure everything looks pixel-perfect (e.g. nothing gets badly cropped).
        // TODO: reinstate the masks for heads and tails.
        // TODO: fix handling when edge is very small (e.g. when the label contains the entire edge).
        // TODO: fix handling for n-cells for high n.
        // TODO: investigate saving as SVG.
        // TODO: investigate loops.
        // TODO: work out how to output tikz-cd code for curved edges.
        // TODO: use the new arrow library for quiver.
        // TODO: refactor.

        let drag = null;
        let curve = 0;
        let level = 1;
        // How much padding (in pixels) to add between the endpoints and the arrowheads/tails.
        let shorten = 20;

        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 64;
                this.height = 64;
                this.svg = document.createElement("div");
                this.svg.classList.add("box");
                this.redraw();
                this.svg.addEventListener("mousedown", (event) => {
                    if (drag === null) {
                        const rect = this.svg.getBoundingClientRect();
                        drag = [this, event.clientX - rect.left - this.width / 2, event.clientY - rect.top - this.height / 2];
                    }
                });
                document.body.appendChild(this.svg);
            }

            redraw() {
                this.svg.style.left = `${this.x - this.width / 2}px`;
                this.svg.style.top = `${this.y - this.height / 2}px`;
                this.svg.style.width = `${this.width}px`;
                this.svg.style.height = `${this.height}px`;
            }
        }

        class Arrow {
            constructor(source, target) {
                this.source = source;
                this.target = target;
                const ns = "http://www.w3.org/2000/svg";
                // We need to explicitly set the namespace attribute so that the SVG can be saved as
                // a standalone file.
                this.svg = new DOM.SVGElement("svg", { xmlns: ns });
                this.redraw();
                document.body.appendChild(this.svg.element);
            }

            redraw() {
                const SPACING = 4.5;
                const STROKE_WIDTH = 1.5;

                const body_shape = "line"; // "squiggly", "line", "none", "adjunction"

                // The height (in pixels) of each triangle from the edge.
                const AMPLITUDE = 2;

                const PADDING_Y = body_shape === "squiggly" ? (AMPLITUDE + STROKE_WIDTH) : 0;

                const line_width = level * STROKE_WIDTH + (level - 1) * SPACING;

                const HEAD_WIDTH = (SPACING + STROKE_WIDTH) + (level - 1) * 2;
                const HEAD_HEIGHT = line_width + (SPACING + STROKE_WIDTH) * 2;

                const PADDING_S = 15;
                const PADDING_X = HEAD_HEIGHT / 2 + PADDING_S;

                const length = Math.hypot(this.target.y - this.source.y, this.target.x - this.source.x);
                const height = Math.abs(curve) + HEAD_HEIGHT + PADDING_Y * 2 + PADDING_S * 2;
                const angle = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                const [svg_width, svg_height] = [length + PADDING_X * 2, height];
                this.svg.element.style.width = `${svg_width}px`;
                this.svg.element.style.height = `${svg_height}px`;
                this.svg.element.style.transformOrigin = `0 ${height / 2}px`;
                this.svg.element.style.transform = `translate(${this.source.x}px, ${this.source.y - height / 2}px) rotate(${angle}rad) translate(${-PADDING_X}px, 0)`;

                this.svg.element.innerHTML = "";
                this.svg.element.setAttribute("viewBox", `0 0 ${length} ${height}`);

                const body_style = "none";

                const bg = new DOM.SVGElement("path", {
                    d: `M 0 ${height / 2} q ${length / 2} ${curve} ${length} 0`,
                    fill: "none",
                    stroke: "hsla(0, 0%, 0%, 0.2)",
                    "stroke-width": line_width + PADDING_S * 2,
                    // "stroke-linecap": "round", // could use: http://web.cse.ohio-state.edu/~dey.8/course/784/note9.pdf
                }).add_to(this.svg);
                const line = new DOM.SVGElement("path", {
                    mask: "url(#clip)",
                    fill: "none",
                    stroke: "black",
                    "stroke-width": line_width,
                }).add_to(this.svg);
                if (body_style === "dashed") {
                    line.setAttribute("stroke-dasharray", "6");
                } else if (body_style === "dotted") {
                    line.setAttribute("stroke-dasharray", "2 4");
                }

                const defs = new DOM.SVGElement("defs").add_to(this.svg);
                const clip = new DOM.SVGElement("mask", {
                    id: "clip",
                    maskUnits: "userSpaceOnUse",
                }).add_to(defs);

                const fill = new DOM.SVGElement("rect", {
                    width: length + PADDING_X * 2,
                    height,
                    x: -PADDING_X,
                    fill: "white",
                }).add_to(clip);

                const [label_width, label_height] = [128, 32];
                const [label_x, label_y] = [length / 2, (height + curve) / 2];

                // To offset the rectangle properly, we're going to iterately approximate its location.
                // We first normalise the Bézier curve. Flat Bézier curves must be special-cased.
                // We then find all the intersects of the rectangle of the label with the curve. We
                // want the number of intersections to be zero. We also add padding to the rectangle to
                // simulate thickness of the curve. We set up a range from [0, hypot(width/2, height/2)],
                // which we will binary search between to find the right distance.

                let [lmin, lmax] = [
                    0,
                    Math.abs(curve) / 2 + Math.hypot((label_width + line_width) / 2, (label_height + line_width) / 2)
                ];
                let timeout = 0;
                while (true) {
                    const lavg = (lmax + lmin) / 2;
                    const rect_centre = new Point(label_x, label_y - height / 2).rotate(angle);
                    const intersections = new Bezier(new Point(0, 0), length, curve, angle)
                        .intersections_with_rounded_rectangle(new RoundedRectangle(
                            rect_centre.x + Math.cos(angle + Math.PI / 2) * lavg,
                            rect_centre.y + Math.sin(angle + Math.PI / 2) * lavg,
                            label_width + line_width,
                            label_height + line_width,
                            line_width / 2,
                        ));
                    if (intersections.length === 0) {
                        if (lmax - lmin < 1) {
                            break;
                        }
                        [lmin, lmax] = [lmin, lavg];
                    } else {
                        [lmin, lmax] = [lavg, lmax];
                    }
                    ++timeout;
                    if (timeout > 1000) {
                        console.log("no", curve / 2, lavg);
                        break;
                    }
                    // for (const inter of intersections) {
                    //     new DOM.SVGElement("circle", {
                    //         cx: inter.x,
                    //         cy: inter.y + height / 2,
                    //         r: 8,
                    //         fill: "red",
                    //     }).add_to(this.svg);
                    // }
                }

                const lavg = (lmax + lmin) / 2;
                // console.log("lavg", lavg, curve / 2);

                const label = new DOM.SVGElement("rect", {
                    width: label_width,
                    height: label_height,
                    x: (length - label_width) / 2 + Math.cos(angle + Math.PI / 2) * lavg,
                    y: (height - label_height + curve) / 2 + Math.sin(angle + Math.PI / 2) * lavg,
                    fill: "lime",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                }).add_to(this.svg);
                const text = new DOM.SVGElement("text", {
                    x: label_x + Math.cos(angle + Math.PI / 2) * lavg,
                    y: label_y + Math.sin(angle + Math.PI / 2) * lavg,
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                    "text-anchor": "middle",
                    "dominant-baseline": "middle",
                }).add_to(this.svg);
                text.element.innerHTML = "Label";

                // const points = create_rounded_rect(
                //     label_x, label_y, label_width, label_height, line_width / 2,
                // );
                // let rr_path = "";
                // let first = true;
                // for (const p of points) {
                //     if (first) {
                //         rr_path += `M ${p.x} ${p.y} `;
                //         first = false;
                //     } else {
                //         rr_path += `L ${p.x} ${p.y} `;
                //     }
                // }

                // new DOM.SVGElement("path", {
                //     d: rr_path,
                //     fill: "red",
                //     stroke: "none",
                // }).add_to(this.svg);

                const ir = (colour, rect, resolve) => {
                    let intersections = new Bezier(new Point(this.source.x, this.source.y), length, curve, angle)
                        .intersections_with_rounded_rectangle(new RoundedRectangle(
                            rect.x,
                            rect.y,
                            rect.width,
                            rect.height,
                            16,
                        ));
                    // There should be at most one intersection point: any more indicates the Bézier curve
                    // is very thin, in which case we pick the point closest to the start of the curve if
                    // `min` is true, or the end otherwise.
                    const min = resolve ? -1 : 1;
                    intersections.sort((a, b) => a.x <= b.x ? min : -min);
                    // console.log(intersections);
                    intersections = intersections.slice(0, 1);
                    for (const inter of intersections) {
                        new DOM.SVGElement("circle", {
                            cx: inter.x,
                            cy: inter.y + height / 2,
                            r: 8,
                            fill: colour,
                        }).add_to(this.svg);
                    }
                    return intersections.length > 0 ? intersections[0] : null;
                };

                // When we draw squiggly lines, we essentially have to draw the
                // Bézier curve by ourselves, using line segments, so that we can
                // transform it (i.e. add the triangle waveform pattern).
                const bezier = new Bezier(Point.zero(), length, curve, 0);
                const t_after_length = bezier.t_after_length();

                const start = ir("none", this.source, true);
                const end = ir("none", this.target, false);

                if (start !== null && end !== null) {
                    const start_len = bezier.arc_length(start.t) + shorten;
                    const end_len = bezier.arc_length(end.t) - shorten;
                    const full_len = bezier.arc_length(1);
                    line.set_attribute("stroke-dasharray", `0 ${start_len} ${end_len - start_len} ${full_len - end_len}`);
                    // line.set_attribute("stroke-dashoffset", bezier.arc_length(start.t));
                }

                const MASK_PADDING = 4;

                const bg_mask = new DOM.SVGElement("mask", {
                    id: "bg-mask",
                    maskUnits: "userSpaceOnUse",
                }).add_to(defs);
                bg.set_attribute("mask", "url(#bg-mask)");
                new DOM.SVGElement("rect", {
                    width: svg_width,
                    height: svg_height,
                    x: -PADDING_X,
                    y: -PADDING_Y,
                    fill: "white",
                }).add_to(bg_mask);

                const mask_bg_end = (endpoint, start) => {
                    if (endpoint !== null) {
                        const [w, h] = [
                            Math.hypot(endpoint.x - (start ? 0 : length), endpoint.y) + MASK_PADDING,
                            line_width + PADDING_S * 2 + MASK_PADDING * 2
                        ];
                        new DOM.SVGElement("rect", {
                            width: w, // overapproximation
                            height: h,
                            x: start ? -w : 0,
                            y: -h / 2,
                            fill: "black",
                            // we can use the extra two arguments of rotate instead of x and y here
                            transform: `translate(${endpoint.x}, ${height / 2 + endpoint.y}) rotate(${endpoint.angle * 180 / Math.PI})`,
                        }).add_to(bg_mask);
                        new DOM.SVGElement("circle", {
                            cx: endpoint.x,
                            cy: endpoint.y + height / 2,
                            r: line_width / 2 + PADDING_S,
                            fill: "white",
                        }).add_to(bg_mask);
                    }
                }

                mask_bg_end(start, true);
                mask_bg_end(end, false);

                // this should be a Path
                let path = [`M 0 ${height / 2}`];
                if (body_shape === "line") {
                    path.push(`q ${length / 2} ${curve} ${length} 0`);
                } else if (body_shape === "adjunction") {
                    const proper_path = new Path();
                    const centre = bezier.point(0.5);
                    const angle = bezier.tangent(0.5);
                    const normal = angle + Math.PI / 2;
                    const LENGTH = 16;
                    proper_path.move_to(centre.x - Math.cos(angle) * LENGTH / 2, height / 2 + centre.y - Math.sin(angle) * LENGTH / 2);
                    proper_path.line_by(Math.cos(angle) * LENGTH, Math.sin(angle) * LENGTH);
                    proper_path.move_to(centre.x + Math.cos(angle) * LENGTH / 2 - Math.cos(normal) * LENGTH / 2, height / 2 + centre.y + Math.sin(angle) * LENGTH / 2 - Math.sin(normal) * LENGTH / 2);
                    proper_path.line_by(Math.cos(normal) * LENGTH, Math.sin(normal) * LENGTH);
                    path = proper_path.commands;
                } else if (body_shape === "squiggly") {
                    if (start === null || end === null) {
                        console.error("no start/end");
                    }

                    // Each triangle has a width equal to twice its height.
                    const HALF_WAVELENGTH = AMPLITUDE * 2;

                    // Padding at the start of the edge (measured in triangles), where the curve
                    // will be flat (though possibly curved).
                    const PADDING = 1;

                    // We provide twice as much padding for the head as for the tail.
                    const heads = 1;
                    const head_padding = PADDING * (1 + heads);

                    // Draw the padding at the tail of the arrow.
                    const SVG_PADDING = 0;
                    const line_length = length;
                    const angle = bezier.tangent(0);

                    const arc_length = bezier.arc_length(end.t) - bezier.arc_length(start.t);
                    const squiggle_length = bezier.arc_length(end.t) - (HEAD_WIDTH + HALF_WAVELENGTH * head_padding);

                    // should really be tail width
                    const st = bezier.arc_length(start.t) + HEAD_WIDTH + HALF_WAVELENGTH * head_padding;
                    let ll = t_after_length(st);
                    let lp = bezier.point(ll);
                    path.push(`l ${lp.x} ${lp.y}`);

                    for (
                        // The current (arc) length along the curve.
                        let l = st,
                        // Which direction to draw the triangle (`-1` or `1`).
                        sign = -1,
                        // Whether to draw offset by `AMPLITUDE` (`1`) or not (`0`).
                        m = 1;
                        l + m * HALF_WAVELENGTH / 2 < squiggle_length;
                        // Flip the direction of the triangle each time a triangle
                        // is drawn. We alternate between drawing tips and bases of
                        // the triangles.
                        sign = [sign, -sign][m], m = 1 - m
                    ) {
                        l += HALF_WAVELENGTH / 2;
                        const t = t_after_length(l);
                        const point = bezier.point(t);
                        const angle = bezier.tangent(t) + Math.PI / 2 * sign;
                        path.push(`L ${
                            point.x + Math.cos(angle) * AMPLITUDE * m
                        } ${
                            height / 2 + point.y + Math.sin(angle) * AMPLITUDE * m
                        }`);
                    }

                    // Draw the padding at the head of the arrow.
                    path.push(`L ${SVG_PADDING + line_length} ${
                        SVG_PADDING + height / 2
                    }`);
                }

                let cut = true;
                for (let i = level - 1; i > 0; --i) {
                    new DOM.SVGElement("path", {
                        d: path.join("\n"),
                        fill: "none",
                        stroke: cut ? "black" : "white",
                        "stroke-width": `${(i - (cut ? 1 : 0)) * STROKE_WIDTH + (i - (cut ? 0 : 1)) * SPACING}`,
                    }).add_to(clip);
                    cut = !cut;
                }

                new DOM.SVGElement("rect", {
                    width: this.source.width,
                    height: this.source.height,
                    x: -this.source.width / 2,
                    y: (height - this.source.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} 0 ${height / 2})`,
                    rx: 16,
                }).add_to(clip);

                // visualise_rounded_rect(this.svg, 0, height / 2, this.source.width, this.source.height, 16);

                new DOM.SVGElement("rect", {
                    width: this.target.width,
                    height: this.target.height,
                    x: length - this.target.width / 2,
                    y: (height - this.target.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length} ${height / 2})`,
                    rx: 16,
                }).add_to(clip);

                line.element.setAttribute("d", path.join("\n"));

                const create_head = (heads, bezier, where, is_start, mask) => {
                    const head = new DOM.SVGElement("path", {
                        fill: mask ? "red" : "none",
                        stroke: !mask ? "black" : "none",
                        "stroke-width": STROKE_WIDTH,
                    });
                    const mul = is_start ? 1 : -1;
                    const flag = is_start ? 0 : 1;
                    let head_path = new Path();

                    const is_harpoon = heads.length === 1 && heads[0].startsWith("harpoon");

                    if (!is_harpoon) {
                        const HEAD_SPACING = 2;
                        let arclen = bezier.arc_length(where.t) + shorten * mul;
                        const ts = [];
                        let prev_margin = 0;
                        for (let i = 0; i < heads.length; ++i) {

                            let margin_left, margin_right, margin_start;
                            switch (heads[i]) {
                                case "epi":
                                case "corner":
                                    [margin_left, margin_right, margin_start]
                                        = [HEAD_WIDTH, 0, 0]; break;
                                case "mono":
                                case "hook":
                                    [margin_left, margin_right, margin_start]
                                        = [0, HEAD_WIDTH, HEAD_WIDTH]; break;
                                case "maps to":
                                    [margin_left, margin_right, margin_start]
                                        = [HEAD_WIDTH / 2, HEAD_WIDTH / 2, 0]; break;
                            }

                            if (i === 0) {
                                arclen += margin_start * mul;
                            } else {
                                // When we have multiple heads of the same type in a row, we can
                                // collapse them together, because each will fill the whitespace
                                // area of the previous.
                                const collapse = heads[i] === heads[i - 1] ? 2 : 1;
                                arclen += ((prev_margin + margin_right) / collapse + HEAD_SPACING) * mul;
                            }

                            prev_margin = margin_left;

                            ts.push(t_after_length(arclen));
                        }
                        for (let i = heads.length - 1; i >= 0; --i) {
                            const type = heads[i];
                            for (const [iflag, imul] of [[flag, -1], [1 - flag, 1]]) {
                                const off = bezier.point(ts[i]);
                                head_path.move_to(
                                    off.x,
                                    off.y + height / 2,
                                );
                                const angle = bezier.tangent(ts[i]) + (type === "mono" || type === "hook" ? Math.PI : 0);
                                if (type === "epi" || type === "mono") {
                                    const [dx, dy] = [mul * HEAD_WIDTH, imul * HEAD_HEIGHT / 2];
                                    head_path.arc_by(
                                        mul * HEAD_WIDTH,
                                        HEAD_HEIGHT / 2,
                                        angle * 180 / Math.PI,
                                        false,
                                        iflag,
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                    if (mask && type === "epi") {
                                        let [mdx, mdy] = [-mul * (HEAD_WIDTH + MASK_PADDING), 0];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                        [mdx, mdy] = [0, -imul * HEAD_HEIGHT / 2];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                    }
                                    if (mask && type === "mono") {
                                        let [mdx, mdy] = [mul * MASK_PADDING, 0];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                        [mdx, mdy] = [0, -imul * HEAD_HEIGHT / 2];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                    }
                                } else if (type === "corner") {
                                    // we need to adjust the background padding here, depending on the angle
                                    const LENGTH = 12;
                                    const base_2 = LENGTH / Math.sqrt(2);
                                    const p = bezier.point(t_after_length(bezier.arc_length(ts[i]) + base_2 * mul));
                                    // the initial move is unncessary here
                                    head_path.move_to(
                                        p.x,
                                        p.y + height / 2,
                                    );

                                    // Round the angle to the nearest 45º and adjust with respect to the
                                    // current direction.
                                    const PI_4 = Math.PI / 4;
                                    const direction = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                                    const ang = Math.PI + PI_4 * Math.round(4 * direction / Math.PI) - direction;

                                    head_path.line_by(
                                        Math.cos(ang + Math.PI * (1 - flag) + imul * Math.PI / 4) * LENGTH,
                                        Math.sin(ang + Math.PI * (1 - flag) + imul * Math.PI / 4) * LENGTH,
                                    );
                                } else if (type === "maps to") {
                                    const [dx, dy] = [0, imul * HEAD_HEIGHT / 2];
                                    head_path.line_by(
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                } else if (type === "hook") {
                                    const [dx, dy] = [0, -imul * HEAD_WIDTH * 2];
                                    head_path.arc_by(
                                        -mul * HEAD_WIDTH,
                                        HEAD_WIDTH,
                                        // We're drawing a semicircle,
                                        // so the angle is actually unimportant.
                                        angle * 180 / Math.PI,
                                        // This flag appears to be unimportant here.
                                        false,
                                        !iflag,
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                    if (mask) {
                                        let [mdx, mdy] = [mul * (HEAD_WIDTH + MASK_PADDING), 0];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                        [mdx, mdy] = [0, imul * HEAD_WIDTH * 2];
                                        head_path.line_by(
                                            mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                            mdx * Math.sin(angle) + mdy * Math.cos(angle),
                                        );
                                    }
                                }
                                // only draw mask for final head/tail
                                // if (i === heads - 1 && mask) {
                                //     head_path.line_to(
                                //         off.x + mul * (HEAD_WIDTH + HEAD_SPACING) * i,
                                //         height / 2 + imul * HEAD_HEIGHT / 2 + off.y,
                                //     );
                                //     head_path.line_to(
                                //         off.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                //         height / 2 + imul * HEAD_HEIGHT / 2 + off.y,
                                //     );
                                //     head_path.line_to(
                                //         off.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                //         height / 2 + off.y,
                                //     );
                                // }
                            }
                        }
                        head.element.setAttribute("d", head_path.toString());
                    } else if (is_harpoon) {
                        const h = line_width + SPACING;
                        const flip = heads[0].endsWith("top") ? 1 : -1;
                        // Overwrite `where` to taken `shorten` into account.
                        const t = t_after_length(bezier.arc_length(where.t) + shorten * mul);
                        where = bezier.point(t);
                        where.angle = bezier.tangent(t);
                        const angle = where.angle;
                        const rotwhere = where.add(new Point(0, height / 2)).add(new Point(0, flip * line_width / 2 - flip * STROKE_WIDTH / 2).rotate(angle));
                        head_path.move_to(
                            rotwhere.x, rotwhere.y,
                        );
                        // FIXME: refactor out these `dx/dy` parts.
                        const [dx, dy] = [mul * HEAD_WIDTH, -h * flip];
                        head_path.arc_by(
                            mul * HEAD_WIDTH,
                            h,
                            angle * 180 / Math.PI,
                            false,
                            flip === 1 ? flag : 1 - flag,
                            dx * Math.cos(angle) - dy * Math.sin(angle),
                            dx * Math.sin(angle) + dy * Math.cos(angle),
                        );

                        if (mask) {
                            let [mdx, mdy] = [-mul * (HEAD_WIDTH + MASK_PADDING), 0];
                            head_path.line_by(
                                mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                mdx * Math.sin(angle) + mdy * Math.cos(angle),
                            );
                            [mdx, mdy] = [0, h * flip];
                            head_path.line_by(
                                mdx * Math.cos(angle) - mdy * Math.sin(angle),
                                mdx * Math.sin(angle) + mdy * Math.cos(angle),
                            );
                        }
                        head.element.setAttribute("d", head_path.toString());
                        // head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                    }
                    head.element.setAttribute("stroke-linecap", "round");
                    return head;
                }

                let draw_head = (types, bezier, where, is_start) => {
                    const head = create_head(types, bezier, where, is_start, false);
                    if (head !== null) {
                        this.svg.add(head);
                    }
                    const mask = create_head(types, bezier, where, is_start, true);
                    this.svg.add(mask);
                    // if (mask !== null) {
                    //     clip.add(mask);
                    // }
                    // const head2 = create_head(types, bezier, where, is_start, false);
                    // if (head2 !== null) {
                    //     head2.style.stroke = "white";
                    //     clip.appendChild(head2);
                    // }
                };
                // const heads = Array(10).fill("maps to");
                // const heads = Array(10).fill("epi");
                // const heads = Array(10).fill("mono");

                // epi, mono, maps to, harpoon, hook, corner
                const heads = ["harpoon-top"];

                // const heads = ["mono", "epi"];
                // const heads = ["epi", "mono"];
                // const heads = ["mono", "maps to", "epi", "mono", "maps to", "epi"];

                if (body_shape !== "adjunction") {
                    if (start !== null)
                        draw_head(heads, bezier, start, true);
                    if (end !== null)
                        draw_head(heads, bezier, end, false);
                }
            }
        }

        window.addEventListener("mouseup", () => {
            drag = null;
        });

        document.addEventListener("DOMContentLoaded", () => {
            const source = new Shape(64, 240);
            const target = new Shape(640, 240);
            const arrow = new Arrow(source, target);

            window.addEventListener("mousemove", (event) => {
                if (drag !== null) {
                    const [shape, x, y] = drag;
                    shape.x = event.clientX - x;
                    shape.y = event.clientY - y;
                    shape.redraw();
                    arrow.redraw();
                }
            });

            window.addEventListener("wheel", (event) => {
                event.preventDefault();
                curve += event.deltaY;
                arrow.redraw();
            }, { passive: false });

            window.addEventListener("keydown", (event) => {
                let redraw = false;
                if (event.key === "ArrowLeft") {
                    --level;
                    redraw = true;
                }
                if (event.key === "ArrowRight") {
                    ++level;
                    redraw = true;
                }
                level = Math.max(1, level);
                if (redraw) {
                    arrow.redraw();
                }
            })
        });

        function visualise_rounded_rect(svg, x, y, w, h, border_radius) {
            const points = new RoundedRectangle(
                x, y, w, h, border_radius,
            ).points();
            let rr_path = "";
            let first = true;
            for (const p of points) {
                if (first) {
                    rr_path += `M ${p.x} ${p.y} `;
                    first = false;
                } else {
                    rr_path += `L ${p.x} ${p.y} `;
                }
            }

            new DOM.SVGElement("path", {
                d: rr_path,
                fill: "red",
                stroke: "none",
            }).add_to(svg);
        }
    </script>
</head>
<body>
</body>
</html>
