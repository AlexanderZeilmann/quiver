<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>quiver</title>
    <link rel="icon" href="icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
        }

        .box {
            position: absolute;
            background: darkslategrey;
            border-radius: 16px;
        }

        svg {
            overflow: visible;
            position: absolute;
            pointer-events: none;
            /* background: lightgrey; */
        }
    </style>
    <script type="text/javascript" src="ds.js"></script>
    <script type="text/javascript" src="dom.js"></script>
    <script>

        // TODO: add the remaining arrow types: fix the harpoon style.
        // TODO: make sure we can draw arrows between arrows and that they get cropped properly.
        // TODO: make the transition from short arrows to long arrows smooth (e.g. scaling heads, etc.)
        // TODO: add cropping of other arrows (e.g. depth/crossing-over), as well as the label box.
        // TODO: make sure everything looks pixel-perfect.
        // TODO: reinstate the masks for heads and tails.
        // TODO: fix handling when edge is very small (e.g. when the label contains the entire edge).
        // TODO: fix handling for n-cells for high n.
        // TODO: investigate saving as SVG.
        // TODO: investigate loops.
        // TODO: work out how to output tikz-cd code for curved edges.
        // TODO: use the new arrow library for quiver.
        // TODO: refactor.

        let drag = null;
        let curve = 0;
        let level = 1;
        // How much padding (in pixels) to add between the endpoints and the arrowheads/tails.
        let shorten = 20;

        function rad_to_deg(rad) {
            return rad * 180 / Math.PI;
        }

        function deg_to_rad(deg) {
            return deg * Math.PI / 180;
        }

        class Shape {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 64;
                this.height = 64;
                this.svg = document.createElement("div");
                this.svg.classList.add("box");
                this.redraw();
                this.svg.addEventListener("mousedown", (event) => {
                    if (drag === null) {
                        const rect = this.svg.getBoundingClientRect();
                        drag = [this, event.clientX - rect.left - this.width / 2, event.clientY - rect.top - this.height / 2];
                    }
                });
                document.body.appendChild(this.svg);
            }

            redraw() {
                this.svg.style.left = `${this.x - this.width / 2}px`;
                this.svg.style.top = `${this.y - this.height / 2}px`;
                this.svg.style.width = `${this.width}px`;
                this.svg.style.height = `${this.height}px`;
            }
        }

        /// A helper class for dealing with symmetric quadratic Bézier curves.
        class Bezier {
            constructor(start, end, height) {
                this.start = start;
                this.end = end;
                this.height = height;

                // The control point. This is twice the distance from the straight line connecting `start`
                // and `end` as `height`.
                const midpoint = this.start.add(this.end).div(2);
                const normal = this.end.sub(this.start).atan() + Math.PI / 2;
                this.control = midpoint.add(Point.from_length_and_direction(this.height, normal));
            }

            /// Returns the (x, y)-point at t = `t`.
            point(t) {
                return this.start.lerp(this.control, t).lerp(this.control.lerp(this.end, t), t);
            }

            /// Returns the angle of the curve at t = `t`.
            angle(t) {
                return this.control.lerp(this.end, t).sub(this.start.lerp(this.control, t)).atan();
            }

            /// Returns the Bézier curve from t = 0 to t = `t` as a series of points corresponding
            /// to line segments, and their total length.
            /// `{ points, length }`
            delineate(t) {
                // How many pixels of precision we want for the length.
                const EPSILON = 0.25;

                // Start with a single, linear segment.
                const points = [[0, this.point(0)], [t, this.point(t)]];

                let previous_length;
                let length = 0;

                do {
                    // Calculate the current approximation of the arc length.
                    previous_length = length;
                    length = 0;
                    for (let i = 0; i < points.length - 1; ++i) {
                        length += points[i + 1][1].sub(points[i][1]).length();
                    }
                } while (length - previous_length > EPSILON && (() => {
                    // If we're still not within the required precision, double the number of segments.
                    for (let i = 0; i < points.length - 1; ++i) {
                        const t = (points[i][0] + points[i + 1][0]) / 2;
                        points.splice(++i, 0, [t, this.point(t)]);
                    }
                    return true;
                })());

                return { points, length };
            }

            /// Returns the arc length of the Bézier curve from t = 0 to t = `t`.
            /// These Bézier curves are symmetric, so t = `t` to t = 1 can be calculated by inverting the
            /// arc length from t = 0.
            arc_length(t) {
                const { length } = this.delineate(t);
                return length;
            }

            /// Returns a function giving the parameter t of the point a given length along the arc of
            /// the Bézier curve. (It returns a function, rather than the t for a length, to allow
            /// the segments to be cached for efficiency).
            /// The returned function does no error-checking, so ensure that it is only called with
            /// lengths between 0 and the arc length of the curve.
            t_after_length() {
                const { points } = this.delineate(1);
                return (length) => {
                    let distance = 0;
                    for (let i = 0; i < points.length - 1; ++ i) {
                        const segment_length = points[i + 1][1].sub(points[i][1]).length();
                        if (distance + segment_length >= length) {
                            // Lerp the t parameter.
                            return points[i][0]
                                + (points[i + 1][0] - points[i][0]) * (length - distance) / segment_length;
                        }
                        distance += segment_length;
                    }
                };
            }
        }

        class Arrow {
            constructor(source, target) {
                this.source = source;
                this.target = target;
                const ns = "http://www.w3.org/2000/svg";
                // We need to explicitly set the namespace attribute so that the SVG can be saved as
                // a standalone file.
                this.svg = new DOM.SVGElement("svg", { xmlns: ns });
                this.redraw();
                document.body.appendChild(this.svg.element);
            }

            redraw() {
                const SPACING = 4.5;
                const STROKE_WIDTH = 1.5;

                const body_shape = "none"; // "squiggly", "line", "none", "adjunction"

                // The height (in pixels) of each triangle from the edge.
                const AMPLITUDE = 2;

                const PADDING_Y = body_shape === "squiggly" ? (AMPLITUDE + STROKE_WIDTH) : 0;

                const line_width = level * STROKE_WIDTH + (level - 1) * SPACING;

                const HEAD_WIDTH = SPACING + (level - 1) * 2;
                const HEAD_HEIGHT = line_width + SPACING * 2;

                const PADDING_S = 15;
                const PADDING_X = HEAD_HEIGHT / 2 + PADDING_S;

                const length = Math.hypot(this.target.y - this.source.y, this.target.x - this.source.x);
                const height = Math.abs(curve) + HEAD_HEIGHT + PADDING_Y * 2 + PADDING_S * 2;
                const angle = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                const [svg_width, svg_height] = [length + PADDING_X * 2, height];
                this.svg.element.style.width = `${svg_width}px`;
                this.svg.element.style.height = `${svg_height}px`;
                this.svg.element.style.transformOrigin = `0 ${height / 2}px`;
                this.svg.element.style.transform = `translate(${this.source.x}px, ${this.source.y - height / 2}px) rotate(${angle}rad) translate(${-PADDING_X}px, 0)`;

                this.svg.element.innerHTML = "";
                this.svg.element.setAttribute("viewBox", `0 0 ${length} ${height}`);

                const body_style = "none";

                const bg = new DOM.SVGElement("path", {
                    d: `M 0 ${height / 2} q ${length / 2} ${curve} ${length} 0`,
                    fill: "none",
                    stroke: "hsla(0, 0%, 0%, 0.2)",
                    "stroke-width": line_width + PADDING_S * 2,
                    // "stroke-linecap": "round", // could use: http://web.cse.ohio-state.edu/~dey.8/course/784/note9.pdf
                }).add_to(this.svg);
                const line = new DOM.SVGElement("path", {
                    mask: "url(#clip)",
                    fill: "none",
                    stroke: "black",
                    "stroke-width": line_width,
                }).add_to(this.svg);
                if (body_style === "dashed") {
                    line.setAttribute("stroke-dasharray", "6");
                } else if (body_style === "dotted") {
                    line.setAttribute("stroke-dasharray", "2 4");
                }

                const defs = new DOM.SVGElement("defs").add_to(this.svg);
                const clip = new DOM.SVGElement("mask", {
                    id: "clip",
                    maskUnits: "userSpaceOnUse",
                }).add_to(defs);

                const fill = new DOM.SVGElement("rect", {
                    width: length + PADDING_X * 2,
                    height,
                    x: -PADDING_X,
                    fill: "white",
                }).add_to(clip);

                const [label_width, label_height] = [128, 32];
                const [label_x, label_y] = [length / 2, (height + curve) / 2];

                // To offset the rectangle properly, we're going to iterately approximate its location.
                // We first normalise the Bézier curve. Flat Bézier curves must be special-cased.
                // We then find all the intersects of the rectangle of the label with the curve. We
                // want the number of intersections to be zero. We also add padding to the rectangle to
                // simulate thickness of the curve. We set up a range from [0, hypot(width/2, height/2)],
                // which we will binary search between to find the right distance.

                let [lmin, lmax] = [
                    0,
                    Math.abs(curve) / 2 + Math.hypot((label_width + line_width) / 2, (label_height + line_width) / 2)
                ];
                let timeout = 0;
                while (true) {
                    const lavg = (lmax + lmin) / 2;
                    const rect_centre = new Point(label_x, label_y - height / 2).rotate(angle);
                    const intersections = intersect_bezier_with_rect(
                        rect_centre.x + Math.cos(angle + Math.PI / 2) * lavg,
                        rect_centre.y + Math.sin(angle + Math.PI / 2) * lavg,
                        label_width + line_width,
                        label_height + line_width,
                        new NormalisedBezier(new Point(0, 0), angle, length, curve),
                        line_width / 2,
                    );
                    if (intersections.length === 0) {
                        if (lmax - lmin < 1) {
                            break;
                        }
                        [lmin, lmax] = [lmin, lavg];
                    } else {
                        [lmin, lmax] = [lavg, lmax];
                    }
                    ++timeout;
                    if (timeout > 1000) {
                        console.log("no", curve / 2, lavg);
                        break;
                    }
                    // for (const inter of intersections) {
                    //     new DOM.SVGElement("circle", {
                    //         cx: inter.x,
                    //         cy: inter.y + height / 2,
                    //         r: 8,
                    //         fill: "red",
                    //     }).add_to(this.svg);
                    // }
                }

                const lavg = (lmax + lmin) / 2;
                // console.log("lavg", lavg, curve / 2);

                const label = new DOM.SVGElement("rect", {
                    width: label_width,
                    height: label_height,
                    x: (length - label_width) / 2 + Math.cos(angle + Math.PI / 2) * lavg,
                    y: (height - label_height + curve) / 2 + Math.sin(angle + Math.PI / 2) * lavg,
                    fill: "lime",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                }).add_to(this.svg);
                const text = new DOM.SVGElement("text", {
                    x: label_x + Math.cos(angle + Math.PI / 2) * lavg,
                    y: label_y + Math.sin(angle + Math.PI / 2) * lavg,
                    transform: `rotate(${-angle * 180 / Math.PI} ${length / 2} ${(height + curve) / 2})`,
                    "text-anchor": "middle",
                    "dominant-baseline": "middle",
                }).add_to(this.svg);
                text.element.innerHTML = "Label";

                // const points = create_rounded_rect(
                //     label_x, label_y, label_width, label_height, line_width / 2,
                // );
                // let rr_path = "";
                // let first = true;
                // for (const p of points) {
                //     if (first) {
                //         rr_path += `M ${p.x} ${p.y} `;
                //         first = false;
                //     } else {
                //         rr_path += `L ${p.x} ${p.y} `;
                //     }
                // }

                // new DOM.SVGElement("path", {
                //     d: rr_path,
                //     fill: "red",
                //     stroke: "none",
                // }).add_to(this.svg);

                const ir = (colour, rect, resolve) => {
                    const intersections = intersect_bezier_with_rect(
                        rect.x,
                        rect.y,
                        rect.width,
                        rect.height,
                        new NormalisedBezier(new Point(this.source.x, this.source.y), angle, length, curve),
                        16,
                        resolve,
                    ).slice(0, 1);
                    for (const inter of intersections) {
                        new DOM.SVGElement("circle", {
                            cx: inter.x,
                            cy: inter.y + height / 2,
                            r: 8,
                            fill: colour,
                        }).add_to(this.svg);
                    }
                    return intersections.length > 0 ? intersections[0] : null;
                };

                // When we draw squiggly lines, we essentially have to draw the
                // Bézier curve by ourselves, using line segments, so that we can
                // transform it (i.e. add the triangle waveform pattern).
                const bezier = new Bezier(Point.zero(), new Point(length, 0), curve);
                const t_after_length = bezier.t_after_length();

                const start = ir("none", this.source, true);
                const end = ir("none", this.target, false);

                const bg_mask = new DOM.SVGElement("mask", {
                    id: "bg-mask",
                    maskUnits: "userSpaceOnUse",
                }).add_to(defs);
                bg.set_attribute("mask", "url(#bg-mask)");
                new DOM.SVGElement("rect", {
                    width: svg_width,
                    height: svg_height,
                    x: -PADDING_X,
                    y: -PADDING_Y,
                    fill: "white",
                }).add_to(bg_mask);

                const mask_bg_end = (endpoint, start) => {
                    if (endpoint !== null) {
                        const MASK_PADDING = 4;
                        const [w, h] = [
                            Math.hypot(endpoint.x - (start ? 0 : length), endpoint.y) + MASK_PADDING,
                            line_width + PADDING_S * 2 + MASK_PADDING * 2
                        ];
                        new DOM.SVGElement("rect", {
                            width: w, // overapproximation
                            height: h,
                            x: start ? -w : 0,
                            y: -h / 2,
                            fill: "black",
                            // we can use the extra two arguments of rotate instead of x and y here
                            transform: `translate(${endpoint.x}, ${height / 2 + endpoint.y}) rotate(${endpoint.angle * 180 / Math.PI})`,
                        }).add_to(bg_mask);
                        new DOM.SVGElement("circle", {
                            cx: endpoint.x,
                            cy: endpoint.y + height / 2,
                            r: line_width / 2 + PADDING_S,
                            fill: "white",
                        }).add_to(bg_mask);
                    }
                }

                mask_bg_end(start, true);
                mask_bg_end(end, false);

                // this should be a Path
                let path = [`M 0 ${height / 2}`];
                if (body_shape === "line") {
                    path.push(`q ${length / 2} ${curve} ${length} 0`);
                } else if (body_shape === "adjunction") {
                    const proper_path = new Path();
                    const centre = bezier.point(0.5);
                    const angle = bezier.angle(0.5);
                    const normal = angle + Math.PI / 2;
                    const LENGTH = 16;
                    proper_path.move_to(centre.x - Math.cos(angle) * LENGTH / 2, height / 2 + centre.y - Math.sin(angle) * LENGTH / 2);
                    proper_path.line_by(Math.cos(angle) * LENGTH, Math.sin(angle) * LENGTH);
                    proper_path.move_to(centre.x + Math.cos(angle) * LENGTH / 2 - Math.cos(normal) * LENGTH / 2, height / 2 + centre.y + Math.sin(angle) * LENGTH / 2 - Math.sin(normal) * LENGTH / 2);
                    proper_path.line_by(Math.cos(normal) * LENGTH, Math.sin(normal) * LENGTH);
                    path = proper_path.commands;
                } else if (body_shape === "squiggly") {
                    if (start === null || end === null) {
                        console.error("no start/end");
                    }

                    // Each triangle has a width equal to twice its height.
                    const HALF_WAVELENGTH = AMPLITUDE * 2;

                    // Padding at the start of the edge (measured in triangles), where the curve
                    // will be flat (though possibly curved).
                    const PADDING = 1;

                    // We provide twice as much padding for the head as for the tail.
                    const heads = 1;
                    const head_padding = PADDING * (1 + heads);

                    // Draw the padding at the tail of the arrow.
                    const SVG_PADDING = 0;
                    const line_length = length;
                    const angle = bezier.angle(0);

                    const arc_length = bezier.arc_length(end.t) - bezier.arc_length(start.t);
                    const squiggle_length = bezier.arc_length(end.t) - (HEAD_WIDTH + HALF_WAVELENGTH * head_padding);

                    // should really be tail width
                    const st = bezier.arc_length(start.t) + HEAD_WIDTH + HALF_WAVELENGTH * head_padding;
                    let ll = t_after_length(st);
                    let lp = bezier.point(ll);
                    path.push(`l ${lp.x} ${lp.y}`);

                    for (
                        // The current (arc) length along the curve.
                        let l = st,
                        // Which direction to draw the triangle (`-1` or `1`).
                        sign = -1,
                        // Whether to draw offset by `AMPLITUDE` (`1`) or not (`0`).
                        m = 1;
                        l + m * HALF_WAVELENGTH / 2 < squiggle_length;
                        // Flip the direction of the triangle each time a triangle
                        // is drawn. We alternate between drawing tips and bases of
                        // the triangles.
                        sign = [sign, -sign][m], m = 1 - m
                    ) {
                        l += HALF_WAVELENGTH / 2;
                        const t = t_after_length(l);
                        const point = bezier.point(t);
                        const angle = bezier.angle(t) + Math.PI / 2 * sign;
                        path.push(`L ${
                            point.x + Math.cos(angle) * AMPLITUDE * m
                        } ${
                            height / 2 + point.y + Math.sin(angle) * AMPLITUDE * m
                        }`);
                    }

                    // Draw the padding at the head of the arrow.
                    path.push(`L ${SVG_PADDING + line_length} ${
                        SVG_PADDING + height / 2
                    }`);
                }

                let cut = true;
                for (let i = level - 1; i > 0; --i) {
                    new DOM.SVGElement("path", {
                        d: path.join("\n"),
                        fill: "none",
                        stroke: cut ? "black" : "white",
                        "stroke-width": `${(i - (cut ? 1 : 0)) * STROKE_WIDTH + (i - (cut ? 0 : 1)) * SPACING}`,
                    }).add_to(clip);
                    cut = !cut;
                }

                new DOM.SVGElement("rect", {
                    width: this.source.width,
                    height: this.source.height,
                    x: -this.source.width / 2,
                    y: (height - this.source.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} 0 ${height / 2})`,
                    rx: 4,
                }).add_to(clip);

                // visualise_rounded_rect(this.svg, 0, height / 2, this.source.width, this.source.height, 16);

                new DOM.SVGElement("rect", {
                    width: this.target.width,
                    height: this.target.height,
                    x: length - this.target.width / 2,
                    y: (height - this.target.height) / 2,
                    fill: "black",
                    transform: `rotate(${-angle * 180 / Math.PI} ${length} ${height / 2})`,
                    rx: 4,
                }).add_to(clip);

                line.element.setAttribute("d", path.join("\n"));

                const create_head = (heads, bezier, where, is_start, mask) => {
                    const head = new DOM.SVGElement("path", {
                        fill: mask ? "black" : "none",
                        stroke: !mask ? "black" : "none",
                        "stroke-width": STROKE_WIDTH,
                    });
                    const mul = is_start ? 1 : -1;
                    const flag = is_start ? 0 : 1;
                    let head_path = new Path();

                    const is_harpoon = heads.length === 1 && heads[0].startsWith("harpoon");

                    if (!is_harpoon) {
                        const HEAD_SPACING = 2;
                        let arclen = bezier.arc_length(where.t) + shorten * mul;
                        const ts = [];
                        let prev_margin = 0;
                        for (let i = 0; i < heads.length; ++i) {

                            let margin_left, margin_right, margin_start;
                            switch (heads[i]) {
                                case "epi":
                                case "corner":
                                    [margin_left, margin_right, margin_start]
                                        = [HEAD_WIDTH, 0, 0]; break;
                                case "mono":
                                case "hook":
                                    [margin_left, margin_right, margin_start]
                                        = [0, HEAD_WIDTH, HEAD_WIDTH]; break;
                                case "maps to":
                                    [margin_left, margin_right, margin_start]
                                        = [HEAD_WIDTH / 2, HEAD_WIDTH / 2, 0]; break;
                            }

                            if (i === 0) {
                                arclen += margin_start * mul;
                            } else {
                                // When we have multiple heads of the same type in a row, we can
                                // collapse them together, because each will fill the whitespace
                                // area of the previous.
                                const collapse = heads[i] === heads[i - 1] ? 2 : 1;
                                arclen += ((prev_margin + margin_right) / collapse + HEAD_SPACING) * mul;
                            }

                            prev_margin = margin_left;

                            ts.push(t_after_length(arclen));
                        }
                        for (let i = heads.length - 1; i >= 0; --i) {
                            const type = heads[i];
                            for (const [iflag, imul] of [[flag, -1], [1 - flag, 1]]) {
                                const off = bezier.point(ts[i]);
                                head_path.move_to(
                                    off.x,
                                    off.y + height / 2,
                                );
                                const angle = bezier.angle(ts[i]) + (type === "mono" || type === "hook" ? Math.PI : 0);
                                if (type === "epi" || type === "mono") {
                                    const [dx, dy] = [mul * HEAD_WIDTH, imul * HEAD_HEIGHT / 2];
                                    head_path.arc_by(
                                        mul * HEAD_WIDTH,
                                        HEAD_HEIGHT / 2,
                                        angle * 180 / Math.PI,
                                        false,
                                        iflag,
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                } else if (type === "corner") {
                                    // we need to adjust the background padding here, depending on the angle
                                    const LENGTH = 12;
                                    const base_2 = LENGTH / Math.sqrt(2);
                                    const p = bezier.point(t_after_length(bezier.arc_length(ts[i]) + base_2 * mul));
                                    // the initial move is unncessary here
                                    head_path.move_to(
                                        p.x,
                                        p.y + height / 2,
                                    );

                                    // Round the angle to the nearest 45º and adjust with respect to the
                                    // current direction.
                                    const PI_4 = Math.PI / 4;
                                    const direction = Math.atan2(this.target.y - this.source.y, this.target.x - this.source.x);
                                    const ang = Math.PI + PI_4 * Math.round(4 * direction / Math.PI) - direction;

                                    head_path.line_by(
                                        Math.cos(ang + Math.PI * (1 - flag) + imul * Math.PI / 4) * LENGTH,
                                        Math.sin(ang + Math.PI * (1 - flag) + imul * Math.PI / 4) * LENGTH,
                                    );
                                } else if (type === "maps to") {
                                    const [dx, dy] = [0, imul * HEAD_HEIGHT / 2];
                                    head_path.line_by(
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                } else if (type === "hook") {
                                    const [dx, dy] = [0, -imul * HEAD_WIDTH * 2];
                                    head_path.arc_by(
                                        -mul * HEAD_WIDTH,
                                        HEAD_WIDTH,
                                        // We're drawing a semicircle,
                                        // so the angle is actually unimportant.
                                        angle * 180 / Math.PI,
                                        // This flag appears to be unimportant here.
                                        false,
                                        !iflag,
                                        dx * Math.cos(angle) - dy * Math.sin(angle),
                                        dx * Math.sin(angle) + dy * Math.cos(angle),
                                    );
                                }
                                // if (i === heads - 1 && mask) {
                                //     head_path.line_to(
                                //         off.x + mul * (HEAD_WIDTH + HEAD_SPACING) * i,
                                //         height / 2 + imul * HEAD_HEIGHT / 2 + off.y,
                                //     );
                                //     head_path.line_to(
                                //         off.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                //         height / 2 + imul * HEAD_HEIGHT / 2 + off.y,
                                //     );
                                //     head_path.line_to(
                                //         off.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                //         height / 2 + off.y,
                                //     );
                                // }
                            }
                        }
                        head.element.setAttribute("d", head_path.toString());
                    } else if (is_harpoon) {
                        const h = line_width + SPACING;
                        const flip = heads[0].endsWith("top") ? 1 : -1;
                        // Overwrite `where` to taken `shorten` into account.
                        const t = t_after_length(bezier.arc_length(where.t) + shorten * mul);
                        where = bezier.point(t);
                        where.angle = bezier.angle(t);
                        head_path.move_to(
                            where.x,
                            where.y + height / 2 + flip * line_width / 2,
                        );
                        head_path.arc_by(
                            mul * HEAD_WIDTH,
                            h,
                            0,
                            false,
                            flip === 1 ? flag : 1 - flag,
                            mul * HEAD_WIDTH,
                            -h * flip,
                        );
                        if (mask) {
                            head_path.line_to(
                                where.x + mul * HEAD_WIDTH,
                                height / 2 - (line_width / 2 + SPACING) * flip + where.y,
                            );
                            head_path.line_to(
                                where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                height / 2 - (line_width / 2 + SPACING) * flip + where.y + flip * STROKE_WIDTH * 2,
                            );
                            head_path.line_to(
                                where.x - mul * Math.hypot(this.source.width, this.source.height) / 2,
                                height / 2 + flip * line_width / 2 + where.y + flip * STROKE_WIDTH * 2,
                            );
                        }
                        head.element.setAttribute("d", head_path.toString());
                        head.element.setAttribute("transform", `rotate(${where.angle * 180 / Math.PI} ${where.x} ${where.y + height / 2})`);
                    }
                    return head;
                }

                let draw_head = (types, bezier, where, is_start) => {
                    const head = create_head(types, bezier, where, is_start, false);
                    if (head !== null) {
                        this.svg.add(head);
                    }
                    // const mask = create_head(types, bezier, where, is_start, true);
                    // if (mask !== null) {
                    //     clip.add(mask);
                    // }
                    // const head2 = create_head(types, bezier, where, is_start, false);
                    // if (head2 !== null) {
                    //     head2.style.stroke = "white";
                    //     clip.appendChild(head2);
                    // }
                };
                // const heads = Array(10).fill("maps to");
                // const heads = Array(10).fill("epi");
                // const heads = Array(10).fill("mono");
                const heads = ["corner"];
                // const heads = ["mono", "epi"];
                // const heads = ["epi", "mono"];
                // const heads = ["mono", "maps to", "epi", "mono", "maps to", "epi"];

                if (body_shape !== "adjunction") {
                    if (start !== null)
                        draw_head(heads, bezier, start, true);
                    if (end !== null)
                        draw_head(heads, bezier, end, false);
                }
            }
        }

        window.addEventListener("mouseup", () => {
            drag = null;
        });

        document.addEventListener("DOMContentLoaded", () => {
            const source = new Shape(64, 240);
            const target = new Shape(640, 240);
            const arrow = new Arrow(source, target);

            window.addEventListener("mousemove", (event) => {
                if (drag !== null) {
                    const [shape, x, y] = drag;
                    shape.x = event.clientX - x;
                    shape.y = event.clientY - y;
                    shape.redraw();
                    arrow.redraw();
                }
            });

            window.addEventListener("wheel", (event) => {
                event.preventDefault();
                curve += event.deltaY;
                arrow.redraw();
            }, { passive: false });

            window.addEventListener("keydown", (event) => {
                let redraw = false;
                if (event.key === "ArrowLeft") {
                    --level;
                    redraw = true;
                }
                if (event.key === "ArrowRight") {
                    ++level;
                    redraw = true;
                }
                level = Math.max(1, level);
                if (redraw) {
                    arrow.redraw();
                }
            })
        });

        function visualise_rounded_rect(svg, x, y, w, h, border_radius) {
            const points = create_rounded_rect(
                x, y, w, h, border_radius,
            );
            let rr_path = "";
            let first = true;
            for (const p of points) {
                if (first) {
                    rr_path += `M ${p.x} ${p.y} `;
                    first = false;
                } else {
                    rr_path += `L ${p.x} ${p.y} `;
                }
            }

            new DOM.SVGElement("path", {
                d: rr_path,
                fill: "red",
                stroke: "none",
            }).add_to(svg);
        }

        function create_rounded_rect(x, y, w, h, border_radius) {
            let points = [];

            // must be greater than zero
            const min_side_length = 5;
            const n = border_radius !== 0 ? Math.PI / Math.atan(min_side_length / (2 * border_radius)) : 0;
            const sides = Math.ceil(n);
            const R = border_radius / Math.cos(Math.PI / sides);
            let angle_offset = 0;

            // top right
            points.push(new Point(
                x + w/2,
                y - (h/2 - border_radius),
            ));
            for (let i = 0; i < sides / 4; ++i) {
                const angle = (i + 0.5) / sides * 2 * Math.PI + angle_offset;
                points.push(new Point(
                    x + (w/2 - border_radius) + Math.cos(angle) * R,
                    y - (h/2 - border_radius) - Math.sin(angle) * R,
                ));
            }
            points.push(new Point(
                x + (w/2 - border_radius),
                y - h/2,
            ));
            // top left
            angle_offset += Math.PI / 2;
            points.push(new Point(
                x - (w/2 - border_radius),
                y - h/2,
            ));
            for (let i = 0; i < sides / 4; ++i) {
                const angle = (i + 0.5) / sides * 2 * Math.PI + angle_offset;
                points.push(new Point(
                    x - (w/2 - border_radius) + Math.cos(angle) * R,
                    y - (h/2 - border_radius) - Math.sin(angle) * R,
                ));
            }
            points.push(new Point(
                x - w/2,
                y - (h/2 - border_radius),
            ));
            // bottom left
            angle_offset += Math.PI / 2;
            points.push(new Point(
                x - w/2,
                y + (h/2 - border_radius),
            ));
            for (let i = 0; i < sides / 4; ++i) {
                const angle = (i + 0.5) / sides * 2 * Math.PI + angle_offset;
                points.push(new Point(
                    x - (w/2 - border_radius) + Math.cos(angle) * R,
                    y + (h/2 - border_radius) - Math.sin(angle) * R,
                ));
            }
            points.push(new Point(
                x - (w/2 - border_radius),
                y + h/2,
            ));
            // bottom right
            angle_offset += Math.PI / 2;
            points.push(new Point(
                x + (w/2 - border_radius),
                y + h/2,
            ));
            for (let i = 0; i < sides / 4; ++i) {
                const angle = (i + 0.5) / sides * 2 * Math.PI + angle_offset;
                points.push(new Point(
                    x + (w/2 - border_radius) + Math.cos(angle) * R,
                    y + (h/2 - border_radius) - Math.sin(angle) * R,
                ));
            }
            points.push(new Point(
                x + w/2,
                y + (h/2 - border_radius),
            ));

            const EPSILON = 10 ** (-10);

            // Remove zero-length segments.
            for (let i = points.length - 2; i >= 0; --i) {
                if (Math.abs(points[i].x - points[i + 1].x) <= EPSILON && Math.abs(points[i].y - points[i + 1].y) <= EPSILON) {
                    points.splice(i + 1, 1);
                }
            }

            return points;
        }

        /// The normalised quadratic Bézier curve is the one whose endpoints are (0, 0) and (1, 0)
        /// and whose control point is (0.5, 1). The highest point on the curve is therefore
        /// (0.5, 0.5). The equation of the curve is `y = 2 x (1 - x)`.

        /// Intersects the rectangle centred on `(x, y)` of width `w` and height `h` with the
        /// Bézier curve `b`.
        /// Note that intersecting a Bézier curve with a circle is very difficult in general, so we
        /// approximate rounded rectangles by rectanges for the sake of finding intersections.
        function intersect_bezier_with_rect(x, y, w, h, b, border_radius = 0, min = true) {
            // let points = new Array(4).fill(null).map(() => new Point(x, y));
            // points[0] = points[0].sub(new Point(w/2, h/2));
            // points[1] = points[1].sub(new Point(-w/2, h/2));
            // points[2] = points[2].sub(new Point(-w/2, -h/2));
            // points[3] = points[3].sub(new Point(w/2, -h/2));
            // console.log(border_radius);

            let points = create_rounded_rect(x, y, w, h, border_radius);

            points = points.reverse();

            let intersections = new Set();
            let h_scale = b.h || 1;
            points = points.map((p) => normalise_point(p, new NormalisedBezier(b.o, b.theta, b.l, h_scale)));

            const EPSILON = 10 ** (-10);

            const add_intersection = (int) => {
                intersections.add(new Point(
                    Math.round(int.x * 10 ** 10) / (10 ** 10),
                    Math.round(int.y * 10 ** 10) / (10 ** 10),
                ));
            };

            if (b.h === 0) {
                // Special-case a straight line, as we can't normalise with respect to this curve.
                // We're now trying to intersect with a horizontal line (0, 0) to (1, 0).
                for (let i = 0; i < points.length; ++i) {
                    const endpoints = [points[i], points[(i + 1) % points.length]];
                    if (Math.abs(endpoints[0].x - endpoints[1].x) <= EPSILON) {
                        // x = a.
                        if (endpoints[0].x >= 0 && endpoints[0].x <= 1 && Math.min(endpoints[0].y, endpoints[1].y) <= 0 &&
                            Math.max(endpoints[0].y, endpoints[1].y) >= 0) {
                                add_intersection(new Point(endpoints[0].x, 0));
                            }
                    } else {
                        const m = (endpoints[1].y - endpoints[0].y) / (endpoints[1].x - endpoints[0].x);
                        const c = endpoints[0].y - m * endpoints[0].x;
                        if (Math.abs(m) > EPSILON) {
                            const x = -c / m;
                            if (x >= 0 && x <= 1 && x >= Math.min(endpoints[0].x, endpoints[1].x) && x <= Math.max(endpoints[0].x, endpoints[1].x)) {
                                add_intersection(new Point(x, 0));
                            }
                        } else if (Math.abs(endpoints[0].y) <= EPSILON) {
                            // Lines lie along one another.
                            const mn = Math.min(endpoints[0].x, endpoints[1].x);
                            const mx = Math.max(endpoints[0].x, endpoints[1].x);
                            if (mn <= 1 && mx >= 0) {
                                add_intersection(new Point(Math.max(mn, 0), 0));
                                add_intersection(new Point(Math.min(mx, 1), 0));
                            }
                        }
                    }
                }
            } else {
                // Usual case. Non-trivial.
                for (let i = 0; i < points.length; ++i) {
                    const endpoints = [points[i], points[(i + 1) % points.length]];
                    // Special-case the vertical line, within some margin of precision to avoid floating-point artefacts.
                    if (Math.abs(endpoints[0].x - endpoints[1].x) <= EPSILON) {
                        const y = intersect_bezier_with_vertical_line(endpoints[0].x);
                        if (y >= 0 && y >= Math.min(endpoints[0].y, endpoints[1].y) && y <= Math.max(endpoints[0].y, endpoints[1].y)) {
                            // `y` must be at most 0.5.
                            add_intersection(new Point(endpoints[0].x, y));
                        }
                    } else {
                        const m = (endpoints[1].y - endpoints[0].y) / (endpoints[1].x - endpoints[0].x);
                        const c = endpoints[0].y - m * endpoints[0].x;
                        // Horizontal or sloping lines.
                        const ints = intersect_bezier_with_line(m, c)
                                .filter((x) => x >= 0 && x <= 1 && x >= Math.min(endpoints[0].x, endpoints[1].x) && x <= Math.max(endpoints[0].x, endpoints[1].x))
                                .map((x) => new Point(x, m * x + c));
                        ints.forEach((int) => add_intersection(int));
                    }
                }
            }

            // There should be at most one intersection point: any more indicates the Bézier curve
            // is very thin, in which case we pick the point closest to the start of the curve if
            // `min` is true, or the end otherwise.
            min = min ? -1 : 1;
            intersections = Array.from(intersections);
            intersections.sort((a, b) => a.x <= b.x ? min : -min);

            // Derivative of Bézier curve is `2 - 4x`.
            return intersections.map(p => Object.assign({ t: p.x, angle: Math.atan2((2 - 4 * p.x) * h_scale, b.l) }, p.scale(b.l, h_scale)));
        }

        /// Intersect the line `y = m x + c` with the normalised quadratic Bézier curve and return
        /// the `x` co-ordinate.
        function intersect_bezier_with_line(m, c) {
            const determinant = m ** 2 - 4 * m + 4 - 8 * c;
            if (determinant > 0) {
                return [(2 - m + determinant ** 0.5) / 4, (2 - m - determinant ** 0.5) / 4];
            } else if (determinant === 0) {
                return [(2 - m + determinant ** 0.5) / 4];
            } else {
                return [];
            }
        }

        /// Intersect the line `x = a` with the normalised quadratic Bézier curve and return the `y`
        /// co-ordinate.
        function intersect_bezier_with_vertical_line(a) {
            return 2 * a * (1 - a);
        }

        /// Normalise a point `p` with respect to the Bézier curve `b`.
        function normalise_point(p, b) {
            // Translate the point with respect to the origin.
            p = p.sub(b.o);
            // Rotate -θ around the origin.
            p = p.rotate(-b.theta);
            // Scale the point horizontally and vertically.
            p = p.inv_scale(b.l, b.h);
            return p;
        }

        class NormalisedBezier {
            /// A Bézier curve with origin `o`, angle `theta`, length `l` and (control point)
            /// height `h`.
            constructor(o, theta, l, h) {
                this.o = o;
                this.theta = theta;
                this.l = l;
                this.h = h;
            }
        }

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            static zero() {
                return new Point(0, 0);
            }

            static from_length_and_direction(length, direction) {
                return new Point(Math.cos(direction) * length, Math.sin(direction) * length);
            }

            add(p) {
                return new (this.constructor)(this.x + p.x, this.y + p.y);
            }

            sub(p) {
                return new (this.constructor)(this.x - p.x, this.y - p.y);
            }

            mul(multiplier) {
                return new (this.constructor)(this.x * multiplier, this.y * multiplier);
            }

            div(divisor) {
                return new (this.constructor)(this.x / divisor, this.y / divisor);
            }

            rotate(theta) {
                return new (this.constructor)(
                    this.x * Math.cos(theta) - this.y * Math.sin(theta),
                    this.y * Math.cos(theta) + this.x * Math.sin(theta),
                );
            }

            scale(w, h) {
                return new (this.constructor)(this.x * w, this.y * h);
            }

            inv_scale(w, h) {
                return new (this.constructor)(this.x / w, this.y / h);
            }

            lerp(other, t) {
                return this.add(other.sub(this).mul(t));
            }

            atan() {
                return Math.atan2(this.y, this.x);
            }

            length() {
                return Math.hypot(this.y, this.x);
            }
        }
    </script>
</head>
<body>
</body>
</html>
