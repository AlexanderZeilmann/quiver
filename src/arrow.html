<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>quiver</title>
    <link rel="icon" href="icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
        }

        .box {
            position: absolute;
            background: darkslategrey;
            border-radius: 16px;
        }

        svg {
            overflow: visible;
            position: absolute;
            pointer-events: none;
            /* background: hsla(0, 0%, 0%, 0.3); */
        }
    </style>
    <script type="text/javascript" src="ds.js"></script>
    <script type="text/javascript" src="dom.js"></script>
    <script type="text/javascript" src="bezier.js"></script>
    <script type="text/javascript" src="arrow.js"></script>
    <script>
        // *** WORK TILL COMPLETION ***
        //
        // ** Critical features & Bugs **
        // - Make sure we can draw pretty arrows between arrows.
        // - Make smooth transitions from small edges to long edges (scaling heads, etc.).
        // - Crop space for the label.
        // - Make label handling work well when edge is very small (and when the label contains the edge).
        // - Make n-cells draw well even for high n.
        // - Test and make sure everything looks pixel perfect. Set up a test rig.
        // - Cropping of background.
        // - Add mask for "none" tail for squiggly lines (could maybe use the existing mask background).
        // - Fix labels.
        //
        // ** quiver integration **
        // - Refactor the arrow code and provide a clean API.
        // - Use the new arrow library for quiver.
        // - Figure out how to export appropriate tikz-cd code for curved edges.
        //
        // ** Extra features **
        // - Loops.
        // - Saving as SVG.

        window.addEventListener("mouseup", () => {
            drag = null;
        });

        document.addEventListener("DOMContentLoaded", () => {
            const source = new Shape(64, 240);
            const target = new Shape(640, 240);
            // const arrow2 = new Arrow2(source, target);

            const arrow = new Arrow(source, target, new ArrowStyle());
            arrow.style.heads = ["epi"];
            arrow.style.tails = ["mono"];
            arrow.style.level = 1;
            // arrow.style.dash_style = CONSTANTS.ARROW_DASH_STYLE.DASHED;
            arrow.style.body_style = CONSTANTS.ARROW_BODY_STYLE.SQUIGGLY;
            arrow.redraw();
            document.body.appendChild(arrow.background.element);
            document.body.appendChild(arrow.svg.element);

            window.addEventListener("mousemove", (event) => {
                if (drag !== null) {
                    const [shape, x, y] = drag;
                    shape.x = event.clientX - x;
                    shape.y = event.clientY - y;
                    shape.redraw();
                    arrow.redraw();
                }
            });

            window.addEventListener("wheel", (event) => {
                event.preventDefault();
                arrow.style.curve += event.deltaY;
                arrow.redraw();
            }, { passive: false });

            window.addEventListener("keydown", (event) => {
                let redraw = false;
                if (event.key === "ArrowLeft") {
                    --arrow.style.level;
                    redraw = true;
                }
                if (event.key === "ArrowRight") {
                    ++arrow.style.level;
                    redraw = true;
                }
                arrow.style.level = Math.max(1, arrow.style.level);
                if (redraw) {
                    arrow.redraw();
                }
            })
        });

        function visualise_rounded_rect(svg, x, y, w, h, border_radius) {
            const points = new RoundedRectangle(
                x, y, w, h, border_radius,
            ).points();
            let rr_path = "";
            let first = true;
            for (const p of points) {
                if (first) {
                    rr_path += `M ${p.x} ${p.y} `;
                    first = false;
                } else {
                    rr_path += `L ${p.x} ${p.y} `;
                }
            }

            new DOM.SVGElement("path", {
                d: rr_path,
                fill: "red",
                stroke: "none",
            }).add_to(svg);
        }
    </script>
</head>
<body>
</body>
</html>
